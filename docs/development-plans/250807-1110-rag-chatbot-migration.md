# RAG 챗봇 기능 이주 개발 계획서

> **작성일**: 2025-08-07 11:10  
> **대상**: rag-chatbot → rag-chatbot-2 기능 이주  
> **목적**: Express.js 기반에서 Fastify + TypeScript 기반으로 안전한 마이그레이션  

## 개요

기존 rag-chatbot의 기능들을 새로운 Fastify + TypeScript 환경으로 단계적으로 이주하는 개발 계획입니다. 각 단계별로 테스트와 검증을 거쳐 안정적인 기능 이전을 목표로 합니다.

## 마이그레이션 전략

### 기본 원칙
- **점진적 이주**: 한 번에 하나의 기능만 추가
- **단계별 검증**: 각 단계마다 기능 테스트 수행
- **안정성 우선**: REST API → WebSocket 순으로 점진적 개선
- **타입 안전성**: TypeScript 타입 정의 선행

### 작업 방식
- **구조 우선**: 각 단계 시작 전 관련 타입 정의 및 서비스 클래스 구조 먼저 생성
- **필요한 것만**: 해당 단계에 필요한 폴더/파일만 선택적 생성 (전체 구조 미리 생성 금지)
- **단계별 완성도**: 각 단계의 기본 구조 → 실제 구현 → 테스트 → 다음 단계 진행
- **문서화 병행**: 주요 변경사항은 즉시 문서 업데이트

### 기술 스택 변화
| 구분 | 기존 (rag-chatbot) | 신규 (rag-chatbot-2) |
|------|-------------------|----------------------|
| **프레임워크** | Express.js | Fastify |
| **언어** | JavaScript | TypeScript |
| **실시간 통신** | 없음 | WebSocket (Socket.io) |
| **아키텍처** | 단순 구조 | 레이어드 아키텍처 |

## 상세 개발 단계

### 1단계: 기초 구조 구축 🏗️
**예상 소요시간**: 1-2시간  
**목표**: 노션 연동을 위한 기본 타입 및 구조 정의

#### 작업 내용 (완료)
- [x] **기본 타입 정의**
  - `ApiResponse`, `ServiceStatus`, `HealthStatus` 등 공통 타입
  - `Document`, `DocumentSource`, `DocumentMetadata` 문서 타입
  - `NotionConfig`, `NotionPage`, `NotionQueryResult` 노션 타입

- [x] **노션 서비스 클래스 구조 생성**
  - `NotionService` 클래스 스켈레톤 (초기화, 상태 확인 메서드 포함)
  - `NotionMapper` 데이터 변환 클래스 (노션 → Document 변환)
  - `notion.constants.ts` 노션 관련 상수 정의

- [x] **폴더 구조 생성**
  - 필요한 폴더만 선택적 생성 (`types/`, `services/notion/`)
  - 각 폴더별 index.ts 파일로 export 구조 설정

#### 완료 기준 (달성)
- ✅ 노션 관련 모든 타입 정의 완료, 컴파일 에러 없음
- ✅ NotionService 클래스 기본 구조 생성 완료
- ✅ 타입 안전성 확보 (exactOptionalPropertyTypes 호환)

---

### 2단계: 노션 데이터베이스 연동 📚 ✅ COMPLETED
**예상 소요시간**: 2-3시간  
**목표**: 노션에서 문서 데이터 읽기 기능

#### 작업 내용
- [x] **테스트 환경 설정**
  - `.env.test` 파일 생성 및 환경변수 설정
  - Jest 테스트 프레임워크 구성 및 최적화
  - NotionService 단위 테스트 작성 및 모킹

- [x] **노션 서비스 기본 구조**
  - NotionService 클래스 생성자 및 초기화 메서드
  - 연결 상태 확인 및 헬스체크 연동
  - 기본 에러 핸들링 구조

- [x] **노션 API 연동 구현** ✅
  - `getPages()` 메서드: 데이터베이스 쿼리 기능 구현
  - `getPageContent()` 메서드: 페이지 내용 읽기 구현  
  - `queryDatabase()` 메서드: 필터링된 쿼리 기능

- [x] **데이터 변환 로직** ✅
  - Notion 블록 → 마크다운 변환 기본 구현
  - 문서 메타데이터 추출 (제목, 수정일, URL 등)
  - `NotionPage` 타입으로 정규화

- [x] **에러 핸들링**
  - API 호출 실패 처리 구조
  - 타임아웃 및 재시도 로직 기본 구조
  - 테스트를 통한 에러 시나리오 검증

#### 완료 기준 (모두 달성 ✅)
- [x] 헬스체크에서 노션 연결 상태 확인 가능
- [x] 노션 데이터베이스에서 문서 목록 조회 가능
- [x] 개별 문서 내용을 마크다운으로 변환 가능

#### 구현 완료 사항
- **NotionService 메서드 구현**: `getPages(filter?)`, `getPage(pageId)` 실제 로직 완료
- **메서드 통합 및 개선**: 
  - `getPages()` + `queryDatabase()` → `getPages(filter?)` 통합
  - `getPageContent()` → `getPage()` 네이밍 개선
  - 매직 넘버를 상수로 대체 (`MAX_NOTION_PAGE_SIZE`)
- **관심사 분리**: 
  - 데이터 변환 로직을 `NotionMapper`로 완전 이동
  - 블록 타입 상수 활용 (`NOTION_BLOCK_TYPES`)
- **타입 중복 제거**: `NotionPage.title`과 `properties.title` 중복 해결
- **기본 마크다운 변환**: 제목, 문단, 리스트 등 주요 블록 타입 지원
- **에러 처리**: API 호출 실패, 타입 안전성, 로깅 완료
- **포괄적 테스트 구현**: ✅
  - **NotionService 테스트**: 43개 테스트 케이스 (정상/에러 케이스 포함)
  - **NotionMapper 테스트**: 모든 유틸리티 메서드 검증
  - **테스트 커버리지**: NotionService/NotionMapper 99%+ 달성
  - **실행 속도**: 0.7초 내 완료 (개발 흐름 방해 없음)

---

### 3단계: OpenAI 임베딩 연동 📊
**예상 소요시간**: 1-1.5시간  
**목표**: 텍스트를 벡터 임베딩으로 변환하는 기능 구현

#### 세부 단계
##### 3-1단계: OpenAI 기본 설정 및 연결 (30-45분) ✅ COMPLETED
- [x] **OpenAI 패키지 설치 및 환경변수 설정**
  - `openai` 패키지 설치 완료
  - `OPENAI_API_KEY` 환경변수 추가 완료
  - API 키 유효성 검증 로직 구현

- [x] **설정 및 클라이언트 구조**
  - `OpenAIConfig` 타입 정의 완료
  - `createOpenAIConfig()` 함수 구현 완료
  - 기본 OpenAI 클라이언트 초기화 완료
  - 헬스체크에 OpenAI 연결 상태 추가 완료

- [x] **추가 완료 사항**
  - 의사결정 문서 2개 작성 (설정 관리 전략, 임베딩 모델 선택)
  - 개념 설명 문서 작성 (임베딩과 벡터 검색)
  - 통합 테스트 스크립트 작성 (`test-openai-integration.ts`)
  - 포괄적 단위 테스트 작성 (설정 18개 + 클라이언트 21개 테스트)
  - TypeScript 타입 에러 해결 (Node.js, Jest 타입)

##### 3-2단계: 임베딩 서비스 구현 (45-60분) ✅ COMPLETED
- [x] **EmbeddingService 클래스 생성**
  - 텍스트 → 벡터 임베딩 변환 기본 기능 완료
  - `text-embedding-3-small` 모델 사용
  - 토큰 제한 처리 (8191 토큰 제한)
  - 배치 처리, 긴 텍스트 청킹 최적화 완료

- [x] **에러 처리 및 최적화**
  - API 호출 실패 재시도 로직 완료 (지수 백오프)
  - tiktoken 기반 정확한 토큰 계산 및 텍스트 분할
  - 로깅 및 사용량 추적 완료
  - FIFO 캐싱으로 성능 최적화

- [x] **단위 테스트 작성**
  - 20+ 테스트 케이스 완료 (정상/에러/경계값 모든 시나리오)
  - 성능 최적화로 실행시간 9초 → 1.5초 단축 (83% 개선)
  - 캐싱, 배치 처리, 청킹, 사용량 추적 모든 기능 검증

#### 완료 기준 (모두 달성 ✅)
- [x] OpenAI API 연결 및 인증 성공 ✅
- [x] 텍스트를 1536차원 벡터로 변환 가능 ✅
- [x] 헬스체크에서 OpenAI 상태 확인 가능 ✅
- [x] 단위 테스트 통과 ✅

#### 3-1단계 구현 완료 사항 ✅
- **패키지 및 환경 설정**: OpenAI 패키지 설치, 환경변수 구성 완료
- **타입 시스템**: `OpenAIConfig`, `OpenAIServiceStatus` 등 모든 필요 타입 정의
- **설정 관리**: 환경변수+상수 조합 방식으로 유연한 설정 시스템 구축
- **클라이언트 래퍼**: `OpenAIClient` 클래스로 API 연결, 상태 관리, 에러 처리
- **서버 통합**: Fastify 서버에 OpenAI 클라이언트 통합, 헬스체크 연동
- **문서화**: 기술 의사결정 2개, 개념 설명 1개 문서 작성
- **테스트**: 통합 테스트 + 단위 테스트 39개 (100% 통과, 0.68초 실행)
- **검증**: 실제 OpenAI API 연결 테스트 성공 (58개 모델 접근 가능)

#### 3-2단계 구현 완료 사항 ✅
- **EmbeddingService 핵심 기능**: 
  - 단일 텍스트 임베딩: `createEmbedding(text)` → 1536차원 벡터 
  - 배치 처리: `createBatchEmbeddings()` 여러 텍스트 일괄 처리
  - 긴 텍스트 처리: `createEmbeddingForLongText()` 자동 청킹 → 여러 벡터
- **토큰 처리 시스템**: 
  - tiktoken 기반 정확한 토큰 계산 (OpenAI와 100% 동일)
  - 8191 토큰 제한 검증 및 자동 텍스트 청킹
  - 200토큰 오버랩으로 문맥 연속성 보장
- **고급 기능**: 
  - FIFO 캐싱으로 중복 요청 방지 (메모리 효율적)
  - 지수 백오프 재시도 로직 (rate limit 대응)
  - 실시간 사용량 추적 ($0.02/1M tokens)
- **성능 최적화**: 
  - 테스트 실행시간 83% 개선 (9초 → 1.5초)
  - tiktoken 성능 검증 (1-8ms, 사용자 인지 불가능)
- **포괄적 테스트**: 20+ 테스트 케이스, 모든 엣지 케이스 커버
- **기술 문서화**: tiktoken 선택 의사결정, 구현 상세 설명 문서 완료

#### 3단계 구현 수준 평가 및 조정 🔄
- **초기 복잡성**: 기본 OpenAI 임베딩 구현 대비 **90배 복잡** (911줄 vs 10줄)
  - tiktoken, FIFO 캐싱, 지수 백오프 재시도, 배치 처리, 청킹 알고리즘 등 고급 기능 포함
  - 프로덕션 레디 수준의 완성도였으나 초기 RAG 구축에는 과도함

- **간단화 결정**: 다른 단계와의 일관성을 위해 기본 구현으로 되돌림
  - **제거된 기능들**: 배치 처리, 긴 텍스트 처리, FIFO 캐싱, tiktoken, 지수 백오프 재시도, 사용량 추적
  - **유지된 기능들**: 기본 임베딩 생성, 간단한 에러 처리, 헬스체크
  - **최종 결과**: 911줄 → 93줄 (90% 감소)

- **고급 기능 보존**: 제거된 고급 기능들은 별도 문서로 보존하여 향후 고도화 시 참조 가능
  - 참조 문서: `docs/advanced-features/embedding-service-advanced-implementation.md`
  - 포함 내용: tiktoken 구현, 캐싱 전략, 재시도 로직, 배치 처리 알고리즘

## 향후 개발 방향성 조정 📋

### 개발 원칙 변경 (4단계부터 적용)
3단계까지는 높은 완성도로 구현되었으나, 초기 RAG 시스템 구축 목적에는 과도한 엔지니어링이었음을 인정하고, 향후 개발에서는 다음 원칙을 엄격히 적용:

#### **새로운 개발 원칙**
1. **최소 기능으로 시작 (MVP First)**
   - RAG가 동작하는 최소 기능만 우선 구현
   - "Just Enough" 엔지니어링 추구
   
2. **필요할 때만 확장 (Progressive Enhancement)**
   - 실제 문제가 발생했을 때 최적화 추가
   - 추측성 최적화 금지

3. **과도한 엔지니어링 자제**
   - 복잡한 에러 처리, 캐싱, 배치 처리 등은 필요 시에만 추가
   - 기본 구현으로도 충분한지 먼저 확인

#### **적용 방법**
- 각 단계 계획 시 "기본 구현" vs "고급 기능" 명확히 구분
- 고급 기능은 "향후 개선사항"으로 분류하여 별도 관리
- 단계별 완료 기준을 "동작하는 최소 기능" 수준으로 설정

---

### 4단계: 벡터 DB (Pinecone) 연동 🔍 ✅ COMPLETED
**예상 소요시간**: 1.5-2시간 (최소 기능 우선)  
**목표**: RAG가 동작하는 기본 벡터 저장/검색 기능 구현

#### 최소 기능 구현 (필수) ✅
- [x] **기본 Pinecone 연결**
  - PineconeClient 클래스 생성 (연결, 기본 에러 처리) ✅
  - 환경변수 설정 및 인덱스 연결 ✅
  
- [x] **핵심 벡터 작업** ✅
  - `upsert()`: 벡터 저장 (ID + 벡터 + 간단한 메타데이터)
  - `query()`: 벡터 검색 (쿼리 벡터 → 유사 벡터 반환)
  - 간단한 임계값 필터링 (score >= 0.7)
  - `deleteDocument()`: 벡터 삭제 기능

- [x] **기본 타입 정의** ✅
  ```typescript
  interface VectorData {
    id: string;
    vector: number[];
    metadata: { title: string; content: string; source: string; timestamp?: string }
  }
  
  interface SearchResult {
    id: string;
    score: number;
    metadata: VectorMetadata;
  }
  
  interface QueryOptions {
    topK?: number;
    scoreThreshold?: number;
  }
  ```

- [x] **헬스체크 통합** ✅
  - 기존 헬스체크에 Pinecone 연결 상태 추가
  - 간단한 인덱스 상태 확인 (벡터 개수 포함)

- [x] **기본 단위 테스트** ✅
  - PineconeService: upsert, query, deleteDocument, healthCheck 메서드 테스트 (13개 테스트)
  - PineconeClient: getIndex, checkConnection, healthCheck 테스트 (4개 테스트)
  - 모킹 기반 테스트 (실제 API 호출 최소화)
  - 모든 테스트 통과 (104개 총 테스트)

#### 향후 개선사항 (나중에 추가)
- 배치 업로드 최적화
- 복잡한 메타데이터 스키마
- 고급 필터링 및 정렬
- 재시도 로직 및 에러 처리 강화
- 성능 모니터링

#### 완료 기준 (최소 동작 수준) ✅
- [x] EmbeddingService 결과를 Pinecone에 저장 가능 ✅
- [x] 쿼리 벡터로 유사 문서 검색 가능 (기본 임계값 적용) ✅
- [x] 헬스체크에서 Pinecone 연결 상태 확인 가능 ✅
- [x] 단위 테스트 통과 (기본 시나리오만) ✅
- [x] RAG 워크플로우 완성: 문서 → 임베딩 → 벡터 저장 → 검색 동작 ✅

#### 4단계 구현 완료 사항 ✅
- **Pinecone 서비스 파일들**:
  - `PineconeClient`: 연결 관리, 인덱스 접근, 상태 확인
  - `PineconeService`: 핵심 벡터 작업 (upsert, query, delete, healthCheck)
  - 타입 정의, 상수 정의, 설정 관리 파일
- **서버 통합**: Fastify 서버에 PineconeService 통합 및 decoration 완료
- **헬스체크 통합**: 기존 헬스체크에 Pinecone 상태 추가 (연결 상태, 인덱스명, 벡터 개수)
- **단위 테스트**: 17개 테스트 케이스 (PineconeService 13개 + PineconeClient 4개)
- **통합 테스트**: 실제 Pinecone + OpenAI API 연동 테스트 스크립트 (`npm run test:pinecone`)
- **TypeScript 완전 지원**: 타입 안전성 보장, exactOptionalPropertyTypes 호환
- **간단한 구현**: 3단계 수준에 맞춘 최소 기능 구현 (고급 기능은 제외)
- **문서화**: Pinecone 핵심 개념, 다중 인덱스 아키텍처, 스마트 검색 전략 설명 문서 작성

---

### 5단계: 기본 문서 처리 파이프라인 🔄
**예상 소요시간**: 1-1.5시간 (최소 기능 우선)  
**목표**: 노션 문서 1개를 벡터로 변환하여 저장하는 기본 파이프라인

#### 최소 기능 구현 (필수)
- [ ] **단일 문서 처리 파이프라인**
  - 노션 문서 1개 → 전체 텍스트 임베딩 → Pinecone 저장
  - 간단한 문서 ID 기반 저장 (중복 방지 없음)
  - 기본 메타데이터만 포함 (title, content, source)

- [ ] **파이프라인 서비스 클래스**
  - `DocumentProcessor` 클래스 생성
  - `processDocument(notionPageId)` 메서드 구현
  - 기본 에러 처리 (실패 시 로그 출력)

- [ ] **통합 테스트 스크립트**
  - 실제 노션 페이지 → Pinecone 저장 → 검색 전체 플로우
  - `scripts/test-full-pipeline.ts` 생성
  - 성공/실패 케이스 기본 확인

#### 향후 개선사항 (나중에 추가)
- 청크 분할 (긴 문서 처리)
- 중복 처리 방지 (해시 기반)
- 증분 업데이트 (변경 감지)
- 배치 작업 처리
- 진행상황 모니터링
- 관리 API

#### 완료 기준 (최소 동작 수준)
- [ ] 노션 페이지 1개를 Pinecone에 저장 가능
- [ ] 저장된 벡터로 유사 문서 검색 가능
- [ ] 통합 테스트 스크립트 동작 확인
- [ ] 전체 RAG 파이프라인 검증: 문서 저장 → 질문 임베딩 → 검색 → 결과 반환

---

### 6단계: 기본 RAG 질의응답 구현 🤖
**예상 소요시간**: 1.5-2시간 (최소 기능 우선)  
**목표**: 질문 → 검색 → 답변 생성의 기본 RAG 플로우

#### 최소 기능 구현 (필수)
- [ ] **질의응답 서비스**
  - `RAGService` 클래스 생성
  - `askQuestion(question: string)` 메서드
  - 기본 프롬프트 템플릿 (하드코딩)

- [ ] **기본 RAG 플로우**
  - 질문 → 임베딩 변환
  - Pinecone에서 관련 문서 검색 (TOP_K=3)
  - 컨텍스트 + 질문 → OpenAI API 호출
  - 간단한 답변 반환

- [ ] **통합 테스트**
  - 전체 RAG 플로우 검증 스크립트
  - 질문 → 답변 생성 동작 확인
  - 출처 정보 포함 여부 검증

#### 향후 개선사항 (나중에 추가)
- 프롬프트 엔지니어링
- 컨텍스트 길이 최적화
- 신뢰도 점수 계산
- 스트리밍 응답
- 고급 에러 처리
- 재시도 로직

#### 완료 기준 (최소 동작 수준)
- [ ] 질문에 대한 기본 답변 생성 가능
- [ ] 출처 문서 정보 포함
- [ ] 통합 테스트로 전체 플로우 검증
- [ ] **RAG 시스템 완전 동작**: 노션 문서 기반 질의응답 완성

---

## 마일스톤 및 검증 포인트

### 마일스톤 1: 데이터 연동 완료 (1-4단계) ✅ COMPLETED
- [x] 노션에서 문서 읽기 가능 ✅
- [x] OpenAI API 연결 및 기본 설정 완료 ✅ (3-1단계)
- [x] OpenAI 임베딩 생성 기능 구현 ✅ (3-2단계)
- [x] Pinecone에 벡터 저장/검색 가능 ✅ (4단계)
- [x] 헬스체크에서 모든 서비스 상태 확인 ✅

### 마일스톤 2: RAG 시스템 완성 (5-6단계)
- [ ] 노션 → Pinecone 파이프라인 동작
- [ ] 질문 → 답변 전체 플로우 완성
- [ ] **RAG 시스템 완전 동작**: 노션 문서 기반 질의응답 완성

### 후속 개발 계획
**7-9단계 (API/UI 구현)**은 별도 문서로 관리:  
📋 `docs/development-plans/250808-0900-rag-api-ui-implementation.md`

- 7단계: 기본 REST 채팅 API
- 8단계: 기본 웹 UI 구현  
- 9단계: 실시간 스트리밍 응답

## 성공 기준

### 기능적 요구사항 (5-6단계 완료 기준)
- [ ] 노션 문서 1개 기반 질의응답 가능
- [ ] 출처 정보 포함된 답변 생성
- [ ] 전체 RAG 파이프라인 동작 검증

### 비기능적 요구사항
- [ ] 답변 생성 시간 10초 이내  
- [ ] 타입 안전성 보장
- [ ] 통합 테스트로 전체 플로우 검증

---

**현재 진행**: [5단계: 기본 문서 처리 파이프라인] 🔄  
**다음 문서**: `docs/development-plans/250808-0900-rag-api-ui-implementation.md`  
**최종 수정일**: 2025-08-08 09:00  
**책임자**: Development Team

## 개발 진행 현황 (2025-08-07 16:15 업데이트)

### 완료된 단계
1. **1단계**: 기초 구조 구축 ✅ 
2. **2단계**: 노션 데이터베이스 연동 ✅ (포괄적 테스트 포함)
3. **3-1단계**: OpenAI 기본 설정 및 연결 ✅ (의사결정 문서 + 단위 테스트)
4. **3-2단계**: 임베딩 서비스 구현 ✅ (간단화 후 안정적 구현)
5. **4단계**: 벡터 DB (Pinecone) 연동 ✅ (단위/통합 테스트 완료)

### 다음 작업
- **5단계**: 기본 문서 처리 파이프라인 🔄

### 주요 성과
- **마일스톤 1 완료**: RAG 시스템의 모든 기반 컴포넌트 구현 완료 ✅
- **총 테스트**: 121개 (100% 통과, 실행시간 < 1.5초)
- **문서화**: 기술 의사결정 3개, 개념 설명 2개, 코드 설명 2개
- **실제 API 검증**: Notion ✅, OpenAI ✅ (임베딩), Pinecone ✅ (벡터 저장/검색)
- **RAG 워크플로우**: 문서 → 임베딩 → 벡터 저장 → 검색 전체 파이프라인 동작 확인
- **타입 안전성**: TypeScript strict 모드 + exactOptionalPropertyTypes 완전 지원
- **성능 최적화**: 테스트 실행 시간 최적화, 모든 API 연동 검증 완료