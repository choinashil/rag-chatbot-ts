# ⚠️ [채택되지 않음] Sixshop Pro 가이드 문서 벡터화 테스트 계획 - 노션 기반

> **⚠️ 중요 알림**: 이 문서는 테스트 및 검토 후 **채택되지 않은** 방식입니다.  
> **채택된 최종 방식**: [단순 HTML 텍스트 추출 방식](./250809-2200-simple-html-text-extraction.md)  
> **채택되지 않은 이유**: API 복잡도, 내부 URL 제한, 과도한 엔지니어링 대비 실용성 부족

> **작성일**: 2025-08-08 16:00 KST  
> **상태**: ❌ **테스트 후 채택되지 않음**  
> **테스트 결과**: 1단계 완료 후 HTML 방식으로 전환  
> **문서 목적**: 노션 API 방식 테스트 과정 기록 및 미채택 사유 보존  

## 개요

실제 회사에서 사용하는 가이드 문서는 기존 MVP 테스트 페이지보다 훨씬 복잡한 구조와 다양한 블록 타입을 포함하고 있습니다. 이 계획은 복잡한 실제 데이터에서 벡터화 프로세스 검증, 문제점 발견 및 해결, 채팅 품질 개선을 통한 프로덕션 레벨 달성을 목표로 합니다.

## 전제 조건

### RAG 시스템 완성 상태 (1-8단계 완료)
- ✅ 노션 연동: 페이지 수집, 콘텐츠 추출, 메타데이터 변환
- ✅ 벡터화: OpenAI 임베딩, Pinecone 저장/검색
- ✅ RAG 플로우: 질문 → 검색 → 컨텍스트 구성 → 답변 생성  
- ✅ 실시간 API: SSE 스트리밍 채팅 API
- ✅ 웹 UI: React 기반 실시간 채팅 인터페이스

### 개발 원칙 (지속 적용)
1. **최소 기능으로 시작 (MVP First)**
2. **필요할 때만 확장 (Progressive Enhancement)**  
3. **과도한 엔지니어링 자제**
4. **문제 발견 시 즉시 기록 및 해결**

---

## 상세 개발 단계

### 1단계: 기본 동작 검증 및 문제 파악 ✅ **완료**
**예상 소요시간**: 30분  
**목표**: 복잡한 실제 데이터에 대한 현재 시스템 처리 능력 평가

#### 최소 기능 구현 (필수)
- [x] **프로젝트 및 설정 분석** ✅
  - `configs/sixshop-pro-collection.json` 설정 확인
  - 수집 대상: 웹사이트 디자인 페이지 (재귀 수집, maxDepth: 5)
  - 옵션: includeDatabase, excludeEmpty 활성화

- [x] **dry-run 테스트 실행** ✅
  - `yarn collect:mixed configs/sixshop-pro-collection.json --env=prod --verbose --dry-run`
  - 실제 API 호출 없이 처리 플로우 검증
  - 에러 및 경고 메시지 수집

- [x] **결과 분석 및 문제점 파악** ✅
  - 성공 사항: 1개 페이지 수집, 47토큰 임베딩 생성, 벡터 저장 완료
  - 발견된 문제: 
    - **블록 타입 미지원**: `callout`, `column_list` 블록
    - **텍스트 추출 부족**: 37자만 추출 (복잡한 구조 대비 적음)

#### 향후 개선사항 (필요시 추가)
- 미지원 블록 타입에 대한 fallback 텍스트 추출
- 복잡한 블록 구조 파싱 알고리즘 개선
- 텍스트 추출 품질 향상

#### 완료 기준 (모두 달성 ✅)
- [x] dry-run 테스트 성공적으로 실행 ✅
- [x] 지원하지 않는 블록 타입 식별 ✅ (callout, column_list)
- [x] 텍스트 추출 품질 이슈 파악 ✅ (37자 vs 예상 분량)
- [x] 다음 단계 진행 가능성 평가 ✅

#### 1단계 구현 인사이트
- **MVP 대비 복잡도**: 실제 회사 문서는 callout, column_list 등 고급 블록 포함
- **텍스트 추출 한계**: 현재 파서로는 복잡한 레이아웃의 정보 손실 발생
- **벡터화 프로세스**: 기본 플로우는 정상 동작, 입력 데이터 품질 개선 필요

---

### 2단계: 실제 데이터 처리 및 벡터화 검증
**예상 소요시간**: 1-1.5시간  
**목표**: 실제 DB 반영을 통한 전체 파이프라인 동작 확인 및 문제 해결

#### 최소 기능 구현 (필수)
- [ ] **블록 타입 지원 개선 (선택적)**
  - callout, column_list 블록의 텍스트 추출 개선 (기본 텍스트만)
  - 복잡한 구조 처리보다는 정보 손실 최소화 우선

- [ ] **실제 DB 반영 테스트**
  - `--dry-run` 제거하고 실제 Pinecone 저장
  - `yarn collect:mixed configs/sixshop-pro-collection.json --env=prod --verbose`
  - 벡터 저장 및 인덱싱 완료 확인

- [ ] **벡터 데이터 검증**
  - `yarn show:vectors` 명령으로 저장된 벡터 확인
  - 메타데이터 구조 및 품질 검증
  - 벡터 유사도 검색 기본 테스트

#### 향후 개선사항 (나중에 추가)
- 고급 블록 파싱 알고리즘
- 문서 버전 관리 및 증분 업데이트
- 대용량 문서 처리 최적화

#### 완료 기준 (최소 동작 수준)
- [ ] 노션 페이지 수집 100% 성공
- [ ] 벡터화 프로세스 에러 없이 완료
- [ ] Pinecone DB에 벡터 정상 저장 확인
- [ ] 기본 벡터 검색 동작 확인

#### 예상 위험 요소 및 대응
- **API 제한 초과**: 재시도 로직 확인, 필요시 배치 크기 조정
- **토큰 제한 초과**: 문서 자동 분할, 청킹 전략 활용
- **네트워크 불안정**: 진행률 저장, 중단점에서 재시작

---

### 3단계: RAG 채팅 기능 검증
**예상 소요시간**: 1시간  
**목표**: 수집된 실제 데이터를 활용한 채팅 응답 품질 테스트

#### 최소 기능 구현 (필수)
- [ ] **채팅 서버 연동 확인**
  - `rag-chatbot-2` API 서버 실행 확인
  - `rag-chatbot-ui` 웹 인터페이스 정상 동작 확인
  - SSE 스트리밍 연결 상태 검증

- [ ] **실제 데이터 기반 질문 테스트**
  - Sixshop Pro 가이드 관련 기본 질문들
  - 수집된 문서에 명시된 구체적 절차 질문
  - 문서에 없는 내용에 대한 응답 처리 확인

- [ ] **응답 품질 평가**
  - 답변 정확성 및 관련성 평가
  - 출처 정보 정확성 검증
  - 응답 시간 및 스트리밍 성능 측정

#### 테스트 시나리오
```
1. 기본 기능 질문: "웹사이트 디자인에서 가장 중요한 요소는?"
2. 구체적 절차: "디자인 시스템 적용 방법은?"  
3. 경계 케이스: "모바일 앱 개발 방법은?" (문서 외 내용)
```

#### 향후 개선사항 (나중에 추가)
- 답변 품질 점수 자동 평가
- 사용자 피드백 수집 시스템
- A/B 테스트 프레임워크

#### 완료 기준 (최소 동작 수준)
- [ ] 채팅 UI에서 실시간 질문/응답 가능
- [ ] 관련 문서 내용 기반 정확한 답변 생성  
- [ ] 문서에 없는 내용은 "정보 부족" 응답
- [ ] 출처 정보 정확히 표시

---

### 4단계: 채팅 품질 개선 작업
**예상 소요시간**: 2-4시간 (발견된 문제에 따라 가변)  
**목표**: 실제 사용 가능한 프로덕션 레벨 품질 달성

#### 개선 영역 (우선순위별)
- [ ] **1순위: 텍스트 추출 품질**
  - 미지원 블록 타입에서 더 많은 텍스트 추출
  - 구조화된 정보(표, 목록) 보존 방법 개선

- [ ] **2순위: 벡터 검색 정확성**
  - 검색 임계값(scoreThreshold) 최적화
  - 검색 결과 개수(topK) 조정
  - 메타데이터 기반 필터링 활용

- [ ] **3순위: 답변 생성 품질**
  - 프롬프트 엔지니어링 개선
  - 컨텍스트 구성 최적화
  - 답변 길이 및 구조 조정

#### 구체적 개선 작업 (필요시 진행)
- [ ] 블록 파서 개선 (callout, column_list 지원)
- [ ] 청킹 전략 최적화 (문서 분할 방법)
- [ ] 프롬프트 템플릿 개선 (도메인 특화)
- [ ] 검색 알고리즘 튜닝 (하이브리드 검색 등)

#### 완료 기준 (품질 목표)
- [ ] 텍스트 추출량 2배 이상 증가 (37자 → 80자+)
- [ ] 관련 질문 정확도 85% 이상
- [ ] 응답 시간 5초 이내 유지
- [ ] 사용자 만족도 기준 달성

---

## 마일스톤 및 검증 포인트

### 마일스톤 1: 기본 처리 검증 완료 (1단계) ✅ **달성**
- [x] dry-run 테스트 성공적 실행 ✅
- [x] 복잡한 구조의 문제점 식별 ✅ (블록 타입 미지원, 텍스트 추출 부족)
- [x] 개선 방향 설정 완료 ✅

### 마일스톤 2: 실제 데이터 처리 완료 (2단계)
- [ ] 실제 DB 반영 성공 (--dry-run 제거)
- [ ] 벡터화 프로세스 에러 없이 완료
- [ ] Pinecone에 저장된 데이터 검증

### 마일스톤 3: RAG 연동 검증 완료 (3단계)
- [ ] 실제 가이드 문서 기반 질의응답 동작
- [ ] 채팅 인터페이스 연동 성공
- [ ] 기본 품질 기준 달성

### 마일스톤 4: 품질 개선 완료 (4단계)
- [ ] 프로덕션 레벨 품질 달성
- [ ] 성능 목표 달성 (응답 시간, 정확도)
- [ ] 개선사항 문서화 완료

## 위험 요소 및 대응 방안

### 기술적 위험
**위험**: 복잡한 노션 블록 구조 파싱 실패  
**대응**: 블록별 fallback 텍스트 추출, 정보 손실 최소화 우선

**위험**: 대용량 문서로 인한 토큰 제한 초과  
**대응**: 기존 청킹 전략 활용, 문서 분할 처리

**위험**: API 호출 제한 또는 타임아웃  
**대응**: 기존 재시도 로직 활용, 배치 크기 조정

### 품질 위험
**위험**: 실제 데이터에서 검색 품질 저하  
**대응**: 검색 파라미터 튜닝, 임계값 조정

**위험**: 복잡한 문서 구조로 인한 응답 품질 저하  
**대응**: 프롬프트 개선, 메타데이터 활용 강화

## 성공 기준

### 기능적 성공 기준 
- [ ] **기본 동작**: Sixshop Pro 가이드 문서 수집 및 벡터화 100% 성공
- [ ] **RAG 연동**: 실제 문서 기반 질의응답 정상 동작
- [ ] **사용자 인터페이스**: 웹 UI를 통한 실시간 채팅 가능

### 품질적 성공 기준
- [ ] **정확도**: 문서 관련 질문 85% 이상 정확한 답변
- [ ] **성능**: 응답 시간 5초 이내 유지
- [ ] **안정성**: 에러율 5% 이하

### 기술적 성공 기준  
- [ ] **데이터 품질**: 텍스트 추출량 현재 대비 2배 이상
- [ ] **시스템 안정성**: 기존 테스트 케이스 모두 통과
- [ ] **모니터링**: 성능 및 품질 지표 추적 가능

## 개발 진행 기록

### 2025-08-08 - 1단계 완료 ✅
- **개발 계획서 작성**: 기존 문서 포맷에 맞춘 상세 계획 수립
- **dry-run 테스트 성공**: 1개 페이지 수집, 47토큰 임베딩, 벡터 저장 플로우 정상
- **문제점 식별**: 
  - `callout`, `column_list` 블록 타입 미지원 → "지원하지 않는 블록에서 텍스트 추출 성공" 메시지 확인
  - 텍스트 추출량 부족 (37자) → 복잡한 구조 대비 정보 손실
- **다음 단계 준비**: 실제 DB 반영 테스트를 위한 준비 완료

### 향후 기록 예정 (각 단계별)
- **2단계**: 실제 DB 반영 결과, 벡터 저장 상태, 발견된 추가 문제점
- **3단계**: 채팅 연동 테스트 결과, 응답 품질 평가, 개선 포인트
- **4단계**: 품질 개선 작업 내용, 성능 개선 결과, 최종 검증

### 개선사항 추적 (지속 업데이트)

#### 2025-08-09 - 벡터화 품질 개선 작업
**기존 구현의 문제점**:
1. **텍스트 추출 부족**: callout, column_list 등 복잡한 블록에서 37자만 추출
2. **링크 정보 손실**: 텍스트와 링크가 분리되어 관계 정보 손실
3. **의미 단위 무시**: 컬럼 내 연관 블록들이 개별적으로 처리되어 컨텍스트 손실
4. **벡터 저장 단위 불명확**: 실제 저장될 형태와 분석 결과 불일치

**개선 내용**:
1. **마크다운 형식 텍스트 추출**: 
   ```typescript
   // 기존: 텍스트와 링크 분리
   { text: "디자인/기능 제작 의뢰하기", links: ["https://bit.ly/3WgTNCY"] }
   
   // 개선: 마크다운 통합 형식
   { markdown: "[디자인/기능 제작 의뢰하기](https://bit.ly/3WgTNCY)", vectorText: "..." }
   ```

2. **의미 단위 청킹 전략**:
   - **Callout + Child Pages**: "고급 코스" callout과 하위 3개 페이지를 하나의 벡터 단위로 처리
   - **빈 블록 기반 분리**: 빈 paragraph를 경계로 의미 있는 섹션 구분
   - **링크 텍스트 + 북마크 결합**: 설명 텍스트와 바로 다음 북마크를 하나의 컨텍스트로 처리

3. **벡터 저장 단위 미리보기**:
   ```
   📝 콘텐츠 단위 #1:
     종류: callout_section
     마크다운: "고급 코스\n코드를 다룰 줄 안다면 더 특별한 웹사이트가 돼요."
     벡터 저장용 텍스트: "고급 코스\n코드를 다룰 줄 안다면 더 특별한 웹사이트가 돼요."
     블록 IDs: [callout_id, child_page1, child_page2, child_page3]
   ```

**개선 결과**:
- **텍스트 추출량 증가**: 단순 37자 → 구조적 컨텍스트 포함한 의미 단위 추출
- **링크 관계 보존**: 마크다운 형식으로 텍스트-링크 관계 유지
- **의미 단위 벡터화**: 연관 블록들이 함께 저장되어 검색 시 더 풍부한 컨텍스트 제공
- **벡터 저장 투명성**: 실제 저장될 형태를 사전에 확인 가능

**다음 검증 계획**:
- 개선된 스크립트로 실제 벡터화 테스트 진행
- 의미 단위 청킹의 검색 품질 개선 효과 측정
- 링크 정보 포함 답변 품질 평가

#### 2025-08-09 - 코드 품질 개선 및 웹사이트 디자인 페이지 최적화 완료
**'웹사이트 디자인' 페이지 패턴 최적화 작업**:

이번 작업은 첫 번째 실제 페이지인 '웹사이트 디자인' 페이지(`e7b780d5b6554f4e8bc957dcfcebfab3`)의 복잡한 블록 구조에 맞춰 벡터화 품질을 개선한 작업입니다.

**페이지별 특화 개선사항**:
1. **Column 구조 처리**: `column_list` → `column` → 내부 블록들의 계층 구조를 의미 단위로 그룹화
   - 컬럼 내 callout + child_page 조합을 하나의 벡터 단위로 처리
   - 예: "고급 코스" callout + 3개 하위 페이지를 하나의 컨텍스트로 벡터화

2. **하위 페이지 관계 보존**: child_page 블록을 단독 처리하지 않고 상위 callout과 연관하여 처리
   - 하위 페이지 제목들을 "관련 페이지: ..." 형태로 포함
   - 노션 URL 생성으로 실제 링크 정보 제공

3. **마크다운 형식 텍스트**: 텍스트와 링크를 분리하지 않고 마크다운 형식으로 통합 보존
   - 예: `[디자인/기능 제작 의뢰하기](https://bit.ly/3WgTNCY)`
   - 검색 시 링크 정보도 함께 제공 가능

4. **의미 단위 청킹**: 빈 블록을 경계로 하는 자연스러운 섹션 분리
   - paragraph + bookmark 연속 처리
   - callout 기반 새 섹션 시작

**코드 품질 개선 (8개 항목 완료)**:
- 타입 안전성 향상 (타입 가드 함수)
- 코드 재사용성 증대 (유틸리티 함수 추출)
- 유지보수성 개선 (상수 분리, 레지스트리 패턴)
- 특정 케이스 로직 단순화

**검증된 벡터 저장 단위 예시** ('웹사이트 디자인' 페이지 기준):
```
📝 콘텐츠 단위 #1:
  종류: callout_section
  마크다운: "고급 코스\n코드를 다룰 줄 안다면 더 특별한 웹사이트가 돼요.\n\n관련 페이지: 디자인 시스템, 커스텀 코드, 웹 접근성"
  벡터 저장용 텍스트: "고급 코스\n코드를 다룰 줄 안다면 더 특별한 웹사이트가 돼요.\n\n관련 페이지: 디자인 시스템 (https://sellerhub.notion.site/abc123), ..."
  블록 IDs: [callout_id, child_page1, child_page2, child_page3]
```

#### 2025-08-09 - 벡터화 전략 및 개발 방법론 수립
**벡터 DB 저장 전략 가이드**:
1. **청킹 크기**: 100-500 토큰 (약 300-1500자) 권장
2. **의미 단위 저장**: 문단별 < **의미 단위** < 문서 전체 (현재 방식 ⭐️ 권장)
3. **메타데이터 구조**:
   ```typescript
   metadata: {
     source: "notion_page",
     pageId: "e7b780d5b6554f4e8bc957dcfcebfab3",
     blockType: "callout_section", 
     hierarchy: ["웹사이트 가이드", "코스 소개"],
     blockIds: [...],
     hasLinks: true,
     hasChildPages: true
   }
   ```

**하이브리드 개발 접근법 결정**:
- **Phase 1**: 범용 처리기 구축 (모든 블록 타입 기본 텍스트 추출, 80% 케이스 커버)
- **Phase 2**: 패턴 학습 (케이스별 분석하며 공통 구조 식별, 90% 케이스 커버)
- **Phase 3**: 도메인 특화 (향후 고려, 95% 품질 달성 목표)

**개발 반영 전략 수립**:
- **실험 단계**: 스크립트에서 빠른 iteration 및 검증 (현재 진행 중)
- **검증 단계**: 2-3개 페이지로 패턴 완성 후 통합 테스트
- **반영 단계**: 검증된 개선사항을 서비스 코드에 한번에 반영 (안정성 최우선)
- **타이밍**: 이번 주 스크립트 완성 → 주말 서비스 반영 → 다음 주 품질 검증

**추가 개선 계획**:
- 하위 페이지 제목 및 링크 정보 포함하여 더 풍부한 컨텍스트 제공
- 링크 URL 정보를 벡터 텍스트에 포함하여 검색 가능성 향상
- 범용 블록 파서 구축으로 미지원 블록 타입 처리 개선

- **블록 타입 지원**: callout, column_list 처리 개선 방안
- **텍스트 추출**: 구조화된 정보 보존 및 추출량 증대 방법
- **검색 품질**: 실제 데이터 기반 벡터 검색 최적화
- **사용자 경험**: 응답 품질 및 속도 개선

#### 2025-08-09 - 헤딩 기반 의미론적 문서 청킹 시스템 구축

**핵심 인사이트**: 노션/HTML 문서는 헤딩(H1, H2, H3) 중심 위계 구조
- **헤딩 = 주요 구분자**: 문서의 의미론적 단위를 구분하는 핵심 기준
- **보조 구분자**: divider, 빈 paragraph로 세부 구분 
- **표현 vs 내용**: callout, column, toggle 등은 표현 방식 차이, 내용 의도는 동일

**현재 시스템 문제점**:
1. **블록 타입 중심 접근**: Column, Callout 등 특정 블록에만 집중
2. **구조 무시**: 문서의 헤딩 위계를 반영하지 않음  
3. **제한적 범위**: `blockAnalyzers` 레지스트리로 일부 블록만 처리
4. **분산된 출력**: 벡터 저장 단위가 불명확

**새로운 접근법: 적응적 계층 청킹 (Adaptive Hierarchical Chunking)**

**핵심 개선사항 (벡터화 전문가 관점)**:

**1. 상위 맥락 보존 문제 해결**
```typescript
interface ChunkWithHierarchy {
  content: string
  hierarchy: {
    pageTitle: string
    h1?: string  
    h2?: string
    h3?: string
  }
  contextualContent: string // "웹사이트 가이드 > 기본 설정 > 테마 선택: 실제내용"
}
```

**2. 노션 실제 계층 구조 활용**
```typescript
interface NotionHierarchy {
  levels: [
    'page_title',      // 페이지 제목
    'heading_1',       // # 제목
    'heading_2',       // ## 제목  
    'heading_3',       // ### 제목
    'callout',         // 📦 중요 정보 (의미적 섹션 구분자)
    'toggle',          // 🔽 접을 수 있는 섹션
    'column_list',     // 📋 컬럼 구조 (레이아웃 구분자)
    'divider'          // ─── 구분선 (명시적 구분자)
  ]
  semanticBoundaries: ['heading_1', 'heading_2', 'heading_3', 'callout', 'divider']
}
```

**3. 성능 최적화 전략**
- **지연 평가(Lazy Evaluation)**: 구조 파악 후 필요시에만 텍스트 길이 계산
- **캐시 전략**: 계산된 섹션 길이 메모리 보존
- **단일 순회**: O(n) 복잡도로 전체 구조 파악

**4. 벡터화 모범 사례 적용**
```typescript
const CHUNK_SIZE_STRATEGY = {
  OPTIMAL_MIN: 300,    // 최소 의미 단위
  OPTIMAL_MAX: 800,    // 검색 최적화 크기 (OpenAI 권장 기준)
  ABSOLUTE_MAX: 1200,  // 모델 한계 고려
  EMERGENCY_SPLIT: 1500 // 강제 분할 기준
} as const
```

**5. 메타데이터 전략**
```typescript
interface ChunkMetadata {
  keywords: string[]          // 핵심 키워드 추출
  summary: string            // 1-2문장 요약
  hierarchyPath: string      // "페이지 > H1 > H2"
  siblingChunks: string[]    // 인접 청크 ID들
  confidence: number         // 청킹 품질 점수
  textDensity: number        // 정보 밀도
}
```

**6. 중복 정보 처리 (Overlap Strategy)**
```typescript
const OVERLAP_STRATEGY = {
  SENTENCE_OVERLAP: 1,      // 문장 1개씩 중복
  CHARACTER_OVERLAP: 50,    // 50자 중복
  SEMANTIC_BRIDGE: true     // 의미 연결점 보존
}
```

**벡터화 전문가 권장 접근법**:
- **의미 기반 청킹** > 고정 크기 청킹 (컨텍스트 보존 우선)
- **하이브리드 청킹**: 의미 단위 + 크기 제한 조합
- **계층적 컨텍스트 상속**: 상위 헤딩 정보를 하위 청크에 포함

**문서 구조별 청킹 전략**:

**케이스 1**: `H3 - paragraph - H3 - paragraph`
```
📊 구조 분석: H3 레벨만 존재, 각 섹션 짧음
💡 전략 선택: H3 단위 분할 + 상위 컨텍스트 상속
📝 결과: "페이지제목 > H3제목: 내용" × 2개 청크
```

**케이스 2**: `H2 - H3 - paragraph - H3 - paragraph - H2`
```
📊 구조 분석: H2(대분류) > H3(소분류) 계층 존재
💡 적응적 전략:
  - H2 단위 총 길이 < 800자 → "페이지 > H2: 전체내용"
  - H2 단위 총 길이 > 800자 → "페이지 > H2 > H3: 각섹션"
📝 결과: 길이에 따른 적응적 컨텍스트 상속
```

**구현 계획**:

**1단계: 문서 전체 구조 분석** (1시간)
- **목표**: 헤딩 계층과 텍스트 길이를 종합적으로 분석
- **구현**:
  ```typescript
  private analyzeDocumentHierarchy(blocks: any[]): DocumentHierarchy {
    // 1. 헤딩 블록들 식별 및 계층 구조 파악
    // 2. 각 헤딩 레벨별 섹션 그룹화 (H1 > H2 > H3)
    // 3. 섹션별 예상 텍스트 길이 측정 (사전 추출)
    // 4. 헤딩이 없는 경우: 기존 Column/Paragraph 기반 fallback
    return {
      levels: ['H1', 'H2', 'H3'],
      sections: [...], 
      textLengths: [...],
      structure: 'hierarchical' | 'flat' | 'mixed'
    }
  }
  ```

**2단계: 적응적 청킹 전략 결정** (30분)
- **목표**: 텍스트 길이 기반으로 최적 청킹 레벨 선택
- **구현**:
  ```typescript
  private determineChunkingStrategy(hierarchy: DocumentHierarchy): ChunkingStrategy {
    const OPTIMAL_CHUNK_SIZE = 300-800 // 벡터 최적 길이
    const MAX_CHUNK_SIZE = 1200        // 벡터 최대 길이
    
    // 전략 1: 상위 레벨 통합 (H2 단위)
    if (h2SectionLength < MAX_CHUNK_SIZE) return 'merge_h2'
    
    // 전략 2: 하위 레벨 분할 (H3 단위) 
    if (h3SectionLength < MAX_CHUNK_SIZE) return 'split_h3'
    
    // 전략 3: 강제 분할 (paragraph/divider 기준)
    return 'force_split'
  }
  ```

**3단계: 적응적 분할 실행** (45분)
- **목표**: 선택된 전략에 따라 실제 청킹 수행
- **구현**:
  ```typescript
  private executeAdaptiveChunking(hierarchy: DocumentHierarchy, strategy: ChunkingStrategy): Chunk[] {
    switch(strategy) {
      case 'merge_h2': 
        return this.createH2LevelChunks(hierarchy)
      case 'split_h3':
        return this.createH3LevelChunks(hierarchy)  
      case 'force_split':
        return this.createParagraphLevelChunks(hierarchy)
      default:
        return this.createFallbackChunks(hierarchy) // 기존 로직 활용
    }
  }
  ```

**4단계: 지능적 출력 시스템** (30분)
- **목표**: 선택된 전략과 청킹 근거를 명시
- **출력 형식**:
  ```
  📚 적응적 계층 청킹 결과:
  🧠 전략: H3 레벨 분할 (H2 단위 길이 초과: 1250자)
  
  📝 청크 #1: "테마 선택하기" (H3 → 적정 길이: 324자)
    계층: H2.기본설정 → H3.테마선택하기
    포함 블록: heading_3, paragraph, callout, child_database (4개)
    벡터 저장용: "테마 선택하기\n\n테마를 선택해주세요..."
    링크: [https://example.com/theme]
    
  📝 청크 #2: "색상 설정하기" (H3 → 적정 길이: 418자)  
    계층: H2.기본설정 → H3.색상설정하기
    포함 블록: heading_3, paragraph, image, callout (4개)
    벡터 저장용: "색상 설정하기\n\n원하는 색상을 선택해주세요..."
  ```

**웹사이트 디자인 입문하기 페이지 적용 예상**:
```
📚 헤딩 기반 문서 청킹 결과:

📝 섹션 #1: "테마 선택하기" (H3)
  포함 블록: heading_3, paragraph, callout, child_database, paragraph (5개)
  벡터 저장용: "테마 선택하기\n\n현재 제공 중인 테마와 템플릿 Essential, Grid, Round..."

📝 섹션 #2: "원하는 테마 선택하기" (H3)  
  포함 블록: heading_3, paragraph, quote, image, paragraph, callout, toggle (7개)
  벡터 저장용: "원하는 테마 선택하기\n\n디자인을 선택하신 후..."

📝 섹션 #3: "테마 설정하기" (H3)
  포함 블록: heading_3, paragraph, image, callout, column_list, column (6개)
  벡터 저장용: "테마 설정하기\n\n상점 디자인은 최대 30개까지 추가할 수 있어요..."
```

**기존 페이지 호환성**:
- 웹사이트 디자인 페이지: 헤딩이 없으므로 전체를 하나의 섹션으로 처리
- 기존 Column 기반 로직은 헤딩 없는 경우의 fallback으로 활용
- 회귀 테스트 통과 보장

**성공 기준**:
1. **구조 인식**: 헤딩 기반 섹션 구분 100% 성공
2. **포괄적 추출**: 13개 모든 블록 타입에서 텍스트 추출  
3. **의미론적 청킹**: 300-1000자 범위의 일관된 섹션 생성
4. **호환성**: 기존 페이지 테스트 통과 유지

**다음 작업**: 1단계 구현 시작 (헤딩 기반 문서 구조 분석)

---

**현재 상태**: 범용 문서 청킹 개선 계획 수립 완료  
**다음 작업**: 사용자 승인 후 구현 시작  
**최종 수정일**: 2025-08-09 16:30  
**책임자**: Development Team